{"version":3,"file":"haxe-2goLdK2a.js","sources":["../node_modules/@codemirror/legacy-modes/mode/haxe.js"],"sourcesContent":["// Tokenizer\n\nfunction kw(type) {return {type: type, style: \"keyword\"};}\nvar A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\");\nvar operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"}, attribute = {type:\"attribute\", style: \"attribute\"};\nvar type = kw(\"typedef\");\nvar keywords = {\n  \"if\": A, \"while\": A, \"else\": B, \"do\": B, \"try\": B,\n  \"return\": C, \"break\": C, \"continue\": C, \"new\": C, \"throw\": C,\n  \"var\": kw(\"var\"), \"inline\":attribute, \"static\": attribute, \"using\":kw(\"import\"),\n  \"public\": attribute, \"private\": attribute, \"cast\": kw(\"cast\"), \"import\": kw(\"import\"), \"macro\": kw(\"macro\"),\n  \"function\": kw(\"function\"), \"catch\": kw(\"catch\"), \"untyped\": kw(\"untyped\"), \"callback\": kw(\"cb\"),\n  \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n  \"in\": operator, \"never\": kw(\"property_access\"), \"trace\":kw(\"trace\"),\n  \"class\": type, \"abstract\":type, \"enum\":type, \"interface\":type, \"typedef\":type, \"extends\":type, \"implements\":type, \"dynamic\":type,\n  \"true\": atom, \"false\": atom, \"null\": atom\n};\n\nvar isOperatorChar = /[+\\-*&%=<>!?|]/;\n\nfunction chain(stream, state, f) {\n  state.tokenize = f;\n  return f(stream, state);\n}\n\nfunction toUnescaped(stream, end) {\n  var escaped = false, next;\n  while ((next = stream.next()) != null) {\n    if (next == end && !escaped)\n      return true;\n    escaped = !escaped && next == \"\\\\\";\n  }\n}\n\n// Used as scratch variables to communicate multiple values without\n// consing up tons of objects.\nvar type, content;\nfunction ret(tp, style, cont) {\n  type = tp; content = cont;\n  return style;\n}\n\nfunction haxeTokenBase(stream, state) {\n  var ch = stream.next();\n  if (ch == '\"' || ch == \"'\") {\n    return chain(stream, state, haxeTokenString(ch));\n  } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n    return ret(ch);\n  } else if (ch == \"0\" && stream.eat(/x/i)) {\n    stream.eatWhile(/[\\da-f]/i);\n    return ret(\"number\", \"number\");\n  } else if (/\\d/.test(ch) || ch == \"-\" && stream.eat(/\\d/)) {\n    stream.match(/^\\d*(?:\\.\\d*(?!\\.))?(?:[eE][+\\-]?\\d+)?/);\n    return ret(\"number\", \"number\");\n  } else if (state.reAllowed && (ch == \"~\" && stream.eat(/\\//))) {\n    toUnescaped(stream, \"/\");\n    stream.eatWhile(/[gimsu]/);\n    return ret(\"regexp\", \"string.special\");\n  } else if (ch == \"/\") {\n    if (stream.eat(\"*\")) {\n      return chain(stream, state, haxeTokenComment);\n    } else if (stream.eat(\"/\")) {\n      stream.skipToEnd();\n      return ret(\"comment\", \"comment\");\n    } else {\n      stream.eatWhile(isOperatorChar);\n      return ret(\"operator\", null, stream.current());\n    }\n  } else if (ch == \"#\") {\n    stream.skipToEnd();\n    return ret(\"conditional\", \"meta\");\n  } else if (ch == \"@\") {\n    stream.eat(/:/);\n    stream.eatWhile(/[\\w_]/);\n    return ret (\"metadata\", \"meta\");\n  } else if (isOperatorChar.test(ch)) {\n    stream.eatWhile(isOperatorChar);\n    return ret(\"operator\", null, stream.current());\n  } else {\n    var word;\n    if(/[A-Z]/.test(ch)) {\n      stream.eatWhile(/[\\w_<>]/);\n      word = stream.current();\n      return ret(\"type\", \"type\", word);\n    } else {\n      stream.eatWhile(/[\\w_]/);\n      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];\n      return (known && state.kwAllowed) ? ret(known.type, known.style, word) :\n        ret(\"variable\", \"variable\", word);\n    }\n  }\n}\n\nfunction haxeTokenString(quote) {\n  return function(stream, state) {\n    if (toUnescaped(stream, quote))\n      state.tokenize = haxeTokenBase;\n    return ret(\"string\", \"string\");\n  };\n}\n\nfunction haxeTokenComment(stream, state) {\n  var maybeEnd = false, ch;\n  while (ch = stream.next()) {\n    if (ch == \"/\" && maybeEnd) {\n      state.tokenize = haxeTokenBase;\n      break;\n    }\n    maybeEnd = (ch == \"*\");\n  }\n  return ret(\"comment\", \"comment\");\n}\n\n// Parser\n\nvar atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true, \"regexp\": true};\n\nfunction HaxeLexical(indented, column, type, align, prev, info) {\n  this.indented = indented;\n  this.column = column;\n  this.type = type;\n  this.prev = prev;\n  this.info = info;\n  if (align != null) this.align = align;\n}\n\nfunction inScope(state, varname) {\n  for (var v = state.localVars; v; v = v.next)\n    if (v.name == varname) return true;\n}\n\nfunction parseHaxe(state, style, type, content, stream) {\n  var cc = state.cc;\n  // Communicate our context to the combinators.\n  // (Less wasteful than consing up a hundred closures on every call.)\n  cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc;\n\n  if (!state.lexical.hasOwnProperty(\"align\"))\n    state.lexical.align = true;\n\n  while(true) {\n    var combinator = cc.length ? cc.pop() : statement;\n    if (combinator(type, content)) {\n      while(cc.length && cc[cc.length - 1].lex)\n        cc.pop()();\n      if (cx.marked) return cx.marked;\n      if (type == \"variable\" && inScope(state, content)) return \"variableName.local\";\n      if (type == \"variable\" && imported(state, content)) return \"variableName.special\";\n      return style;\n    }\n  }\n}\n\nfunction imported(state, typename) {\n  if (/[a-z]/.test(typename.charAt(0)))\n    return false;\n  var len = state.importedtypes.length;\n  for (var i = 0; i<len; i++)\n    if(state.importedtypes[i]==typename) return true;\n}\n\nfunction registerimport(importname) {\n  var state = cx.state;\n  for (var t = state.importedtypes; t; t = t.next)\n    if(t.name == importname) return;\n  state.importedtypes = { name: importname, next: state.importedtypes };\n}\n// Combinator utils\n\nvar cx = {state: null, column: null, marked: null, cc: null};\nfunction pass() {\n  for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n}\nfunction cont() {\n  pass.apply(null, arguments);\n  return true;\n}\nfunction inList(name, list) {\n  for (var v = list; v; v = v.next)\n    if (v.name == name) return true;\n  return false;\n}\nfunction register(varname) {\n  var state = cx.state;\n  if (state.context) {\n    cx.marked = \"def\";\n    if (inList(varname, state.localVars)) return;\n    state.localVars = {name: varname, next: state.localVars};\n  } else if (state.globalVars) {\n    if (inList(varname, state.globalVars)) return;\n    state.globalVars = {name: varname, next: state.globalVars};\n  }\n}\n\n// Combinators\n\nvar defaultVars = {name: \"this\", next: null};\nfunction pushcontext() {\n  if (!cx.state.context) cx.state.localVars = defaultVars;\n  cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};\n}\nfunction popcontext() {\n  cx.state.localVars = cx.state.context.vars;\n  cx.state.context = cx.state.context.prev;\n}\npopcontext.lex = true;\nfunction pushlex(type, info) {\n  var result = function() {\n    var state = cx.state;\n    state.lexical = new HaxeLexical(state.indented, cx.stream.column(), type, null, state.lexical, info);\n  };\n  result.lex = true;\n  return result;\n}\nfunction poplex() {\n  var state = cx.state;\n  if (state.lexical.prev) {\n    if (state.lexical.type == \")\")\n      state.indented = state.lexical.indented;\n    state.lexical = state.lexical.prev;\n  }\n}\npoplex.lex = true;\n\nfunction expect(wanted) {\n  function f(type) {\n    if (type == wanted) return cont();\n    else if (wanted == \";\") return pass();\n    else return cont(f);\n  }\n  return f;\n}\n\nfunction statement(type) {\n  if (type == \"@\") return cont(metadef);\n  if (type == \"var\") return cont(pushlex(\"vardef\"), vardef1, expect(\";\"), poplex);\n  if (type == \"keyword a\") return cont(pushlex(\"form\"), expression, statement, poplex);\n  if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n  if (type == \"{\") return cont(pushlex(\"}\"), pushcontext, block, poplex, popcontext);\n  if (type == \";\") return cont();\n  if (type == \"attribute\") return cont(maybeattribute);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"for\") return cont(pushlex(\"form\"), expect(\"(\"), pushlex(\")\"), forspec1, expect(\")\"),\n                                 poplex, statement, poplex);\n  if (type == \"variable\") return cont(pushlex(\"stat\"), maybelabel);\n  if (type == \"switch\") return cont(pushlex(\"form\"), expression, pushlex(\"}\", \"switch\"), expect(\"{\"),\n                                    block, poplex, poplex);\n  if (type == \"case\") return cont(expression, expect(\":\"));\n  if (type == \"default\") return cont(expect(\":\"));\n  if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"),\n                                   statement, poplex, popcontext);\n  if (type == \"import\") return cont(importdef, expect(\";\"));\n  if (type == \"typedef\") return cont(typedef);\n  return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n}\nfunction expression(type) {\n  if (atomicTypes.hasOwnProperty(type)) return cont(maybeoperator);\n  if (type == \"type\" ) return cont(maybeoperator);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"keyword c\") return cont(maybeexpression);\n  if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeoperator);\n  if (type == \"operator\") return cont(expression);\n  if (type == \"[\") return cont(pushlex(\"]\"), commasep(maybeexpression, \"]\"), poplex, maybeoperator);\n  if (type == \"{\") return cont(pushlex(\"}\"), commasep(objprop, \"}\"), poplex, maybeoperator);\n  return cont();\n}\nfunction maybeexpression(type) {\n  if (type.match(/[;\\}\\)\\],]/)) return pass();\n  return pass(expression);\n}\n\nfunction maybeoperator(type, value) {\n  if (type == \"operator\" && /\\+\\+|--/.test(value)) return cont(maybeoperator);\n  if (type == \"operator\" || type == \":\") return cont(expression);\n  if (type == \";\") return;\n  if (type == \"(\") return cont(pushlex(\")\"), commasep(expression, \")\"), poplex, maybeoperator);\n  if (type == \".\") return cont(property, maybeoperator);\n  if (type == \"[\") return cont(pushlex(\"]\"), expression, expect(\"]\"), poplex, maybeoperator);\n}\n\nfunction maybeattribute(type) {\n  if (type == \"attribute\") return cont(maybeattribute);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"var\") return cont(vardef1);\n}\n\nfunction metadef(type) {\n  if(type == \":\") return cont(metadef);\n  if(type == \"variable\") return cont(metadef);\n  if(type == \"(\") return cont(pushlex(\")\"), commasep(metaargs, \")\"), poplex, statement);\n}\nfunction metaargs(type) {\n  if(type == \"variable\") return cont();\n}\n\nfunction importdef (type, value) {\n  if(type == \"variable\" && /[A-Z]/.test(value.charAt(0))) { registerimport(value); return cont(); }\n  else if(type == \"variable\" || type == \"property\" || type == \".\" || value == \"*\") return cont(importdef);\n}\n\nfunction typedef (type, value)\n{\n  if(type == \"variable\" && /[A-Z]/.test(value.charAt(0))) { registerimport(value); return cont(); }\n  else if (type == \"type\" && /[A-Z]/.test(value.charAt(0))) { return cont(); }\n}\n\nfunction maybelabel(type) {\n  if (type == \":\") return cont(poplex, statement);\n  return pass(maybeoperator, expect(\";\"), poplex);\n}\nfunction property(type) {\n  if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n}\nfunction objprop(type) {\n  if (type == \"variable\") cx.marked = \"property\";\n  if (atomicTypes.hasOwnProperty(type)) return cont(expect(\":\"), expression);\n}\nfunction commasep(what, end) {\n  function proceed(type) {\n    if (type == \",\") return cont(what, proceed);\n    if (type == end) return cont();\n    return cont(expect(end));\n  }\n  return function(type) {\n    if (type == end) return cont();\n    else return pass(what, proceed);\n  };\n}\nfunction block(type) {\n  if (type == \"}\") return cont();\n  return pass(statement, block);\n}\nfunction vardef1(type, value) {\n  if (type == \"variable\"){register(value); return cont(typeuse, vardef2);}\n  return cont();\n}\nfunction vardef2(type, value) {\n  if (value == \"=\") return cont(expression, vardef2);\n  if (type == \",\") return cont(vardef1);\n}\nfunction forspec1(type, value) {\n  if (type == \"variable\") {\n    register(value);\n    return cont(forin, expression)\n  } else {\n    return pass()\n  }\n}\nfunction forin(_type, value) {\n  if (value == \"in\") return cont();\n}\nfunction functiondef(type, value) {\n  //function names starting with upper-case letters are recognised as types, so cludging them together here.\n  if (type == \"variable\" || type == \"type\") {register(value); return cont(functiondef);}\n  if (value == \"new\") return cont(functiondef);\n  if (type == \"(\") return cont(pushlex(\")\"), pushcontext, commasep(funarg, \")\"), poplex, typeuse, statement, popcontext);\n}\nfunction typeuse(type) {\n  if(type == \":\") return cont(typestring);\n}\nfunction typestring(type) {\n  if(type == \"type\") return cont();\n  if(type == \"variable\") return cont();\n  if(type == \"{\") return cont(pushlex(\"}\"), commasep(typeprop, \"}\"), poplex);\n}\nfunction typeprop(type) {\n  if(type == \"variable\") return cont(typeuse);\n}\nfunction funarg(type, value) {\n  if (type == \"variable\") {register(value); return cont(typeuse);}\n}\n\n// Interface\nexport const haxe = {\n  name: \"haxe\",\n  startState: function(indentUnit) {\n    var defaulttypes = [\"Int\", \"Float\", \"String\", \"Void\", \"Std\", \"Bool\", \"Dynamic\", \"Array\"];\n    var state = {\n      tokenize: haxeTokenBase,\n      reAllowed: true,\n      kwAllowed: true,\n      cc: [],\n      lexical: new HaxeLexical(-indentUnit, 0, \"block\", false),\n      importedtypes: defaulttypes,\n      context: null,\n      indented: 0\n    };\n    return state;\n  },\n\n  token: function(stream, state) {\n    if (stream.sol()) {\n      if (!state.lexical.hasOwnProperty(\"align\"))\n        state.lexical.align = false;\n      state.indented = stream.indentation();\n    }\n    if (stream.eatSpace()) return null;\n    var style = state.tokenize(stream, state);\n    if (type == \"comment\") return style;\n    state.reAllowed = !!(type == \"operator\" || type == \"keyword c\" || type.match(/^[\\[{}\\(,;:]$/));\n    state.kwAllowed = type != '.';\n    return parseHaxe(state, style, type, content, stream);\n  },\n\n  indent: function(state, textAfter, cx) {\n    if (state.tokenize != haxeTokenBase) return 0;\n    var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;\n    if (lexical.type == \"stat\" && firstChar == \"}\") lexical = lexical.prev;\n    var type = lexical.type, closing = firstChar == type;\n    if (type == \"vardef\") return lexical.indented + 4;\n    else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n    else if (type == \"stat\" || type == \"form\") return lexical.indented + cx.unit;\n    else if (lexical.info == \"switch\" && !closing)\n      return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? cx.unit : 2 * cx.unit);\n    else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n    else return lexical.indented + (closing ? 0 : cx.unit);\n  },\n\n  languageData: {\n    indentOnInput: /^\\s*[{}]$/,\n    commentTokens: {line: \"//\", block: {open: \"/*\", close: \"*/\"}}\n  }\n};\n\nexport const hxml = {\n  name: \"hxml\",\n  startState: function () {\n    return {\n      define: false,\n      inString: false\n    };\n  },\n  token: function (stream, state) {\n    var ch = stream.peek();\n    var sol = stream.sol();\n\n    ///* comments */\n    if (ch == \"#\") {\n      stream.skipToEnd();\n      return \"comment\";\n    }\n    if (sol && ch == \"-\") {\n      var style = \"variable-2\";\n\n      stream.eat(/-/);\n\n      if (stream.peek() == \"-\") {\n        stream.eat(/-/);\n        style = \"keyword a\";\n      }\n\n      if (stream.peek() == \"D\") {\n        stream.eat(/[D]/);\n        style = \"keyword c\";\n        state.define = true;\n      }\n\n      stream.eatWhile(/[A-Z]/i);\n      return style;\n    }\n\n    var ch = stream.peek();\n\n    if (state.inString == false && ch == \"'\") {\n      state.inString = true;\n      stream.next();\n    }\n\n    if (state.inString == true) {\n      if (stream.skipTo(\"'\")) {\n\n      } else {\n        stream.skipToEnd();\n      }\n\n      if (stream.peek() == \"'\") {\n        stream.next();\n        state.inString = false;\n      }\n\n      return \"string\";\n    }\n\n    stream.next();\n    return null;\n  },\n  languageData: {\n    commentTokens: {line: \"#\"}\n  }\n}\n"],"names":["kw","type","A","B","C","operator","atom","attribute","keywords","isOperatorChar","chain","stream","state","f","toUnescaped","end","escaped","next","content","ret","tp","style","cont","haxeTokenBase","ch","haxeTokenString","haxeTokenComment","word","known","quote","maybeEnd","atomicTypes","HaxeLexical","indented","column","align","prev","info","inScope","varname","v","parseHaxe","cc","cx","combinator","statement","imported","typename","len","registerimport","importname","t","pass","i","inList","name","list","register","defaultVars","pushcontext","popcontext","pushlex","result","poplex","expect","wanted","metadef","vardef1","expression","block","maybeattribute","functiondef","forspec1","maybelabel","funarg","importdef","typedef","maybeoperator","maybeexpression","commasep","objprop","value","property","metaargs","what","proceed","typeuse","vardef2","forin","_type","typestring","typeprop","haxe","indentUnit","defaulttypes","textAfter","firstChar","lexical","closing","hxml","sol"],"mappings":"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","x_google_ignoreList":[0]}